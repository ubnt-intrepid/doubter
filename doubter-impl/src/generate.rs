use std::env;
use std::fs;
use std::io;
use std::path::{Path, PathBuf};

use proc_macro2::{Span, TokenStream};
use syn::Ident;

use markdown;
use parsing::{Input, KeyValue};

#[derive(Debug)]
pub struct Context<'a> {
    input: &'a Input,
    _priv: (),
}

impl<'a> Context<'a> {
    pub fn new(input: &'a Input) -> Context<'a> {
        Context { input, _priv: () }
    }

    fn markdown_files<'c>(&'c self) -> impl Iterator<Item = MarkdownFile<'a>> + 'c {
        self.input.files.iter().map(|input| {
            assert_eq!(input.key, "file");
            MarkdownFile { input }
        })
    }

    fn root_dir(&self) -> PathBuf {
        env::var("CARGO_MANIFEST_DIR").map(PathBuf::from).unwrap()
    }

    pub fn run(&mut self) -> TokenStream {
        let root_dir = self.root_dir();

        let items = self
            .markdown_files()
            .map(|file| {
                let ident = Ident::new(&file.module_name(), Span::call_site());
                let block_constants = file
                    .code_blocks(&root_dir)
                    .expect("failed to read a markdown file")
                    .map(|block| {
                        let ident = Ident::new(&block.constant_name(), Span::call_site());
                        let header = format!("```{}", block.info());
                        let content = block.content();
                        quote!(
                            #[doc = "This doc comment is automatically generated by doubter.\n"]
                            #[doc = #header]
                            #[doc = #content]
                            #[doc = "```"]
                            #[allow(dead_code)]
                            pub const #ident : () = ();
                        )
                    });
                quote!(
                    pub mod #ident {
                        #(#block_constants)*
                    }
                )
            }).collect::<Vec<_>>();

        quote!(
            pub mod doubter_tests {
                #(#items)*
            }
        )
    }
}

#[derive(Debug)]
struct MarkdownFile<'a> {
    input: &'a KeyValue,
}

impl<'a> MarkdownFile<'a> {
    fn module_name(&self) -> String {
        self.input
            .value
            .value()
            .replace('/', "_")
            .replace('.', "_")
            .to_string()
    }

    fn code_blocks(
        &self,
        root_dir: impl AsRef<Path>,
    ) -> io::Result<impl Iterator<Item = CodeBlock<'a>> + 'a> {
        let doc_path = root_dir.as_ref().join(self.input.value.value());
        let content = fs::read_to_string(doc_path)?;
        let input = self.input;
        Ok(markdown::extract_code_blocks(&content)
            .into_iter()
            .map(move |inner| CodeBlock { inner, input }))
    }
}

#[derive(Debug)]
struct CodeBlock<'a> {
    inner: markdown::CodeBlock,
    input: &'a KeyValue,
}

impl<'a> CodeBlock<'a> {
    fn constant_name(&self) -> String {
        format!("line_{}", self.inner.line_number)
    }

    fn info(&self) -> &str {
        self.inner.block_info.as_str()
    }

    fn content(&self) -> &str {
        self.inner.content.as_str()
    }
}
